# 12.Watermark

## 概念


## forBoundedOutOfOrderness Demo

数据之间存在最大固定延迟的时间戳分配器.

一个周期性 watermark 生成的典型例子是，watermark 滞后于数据流中最大（事件时间）时间戳一个固定的时间量。该示例可以覆盖的场景是你预先知道数据流中的数据可能遇到的最大延迟

### 代码

	package wzy
	
	import java.time.Duration
	
	import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}
	import org.apache.flink.api.scala.createTypeInformation
	import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment
	import org.apache.flink.streaming.api.windowing.assigners.{TumblingEventTimeWindows}
	import org.apache.flink.streaming.api.windowing.time.Time
	
	
	object WatermarkDemo {
	
	  def main(args: Array[String]): Unit = {

    val env = StreamExecutionEnvironment.getExecutionEnvironment
    env.setParallelism(1)
    val text = env.socketTextStream("47.112.142.231", 9999)

    val withTimestampsAndWatermarks = text
      .assignTimestampsAndWatermarks(WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(20)) //以传入的时间戳为准，延迟20秒设置watermark
      .withTimestampAssigner(new SerializableTimestampAssigner[String] {
        override def extractTimestamp(t: String, l: Long): Long = {
          t.split(",")(1).toLong * 1000l
        }
      })
      )


    val counts =withTimestampsAndWatermarks
      .map(_.split(",")(0))
      .map { (_, 1) }
      .keyBy( _._1)
      .window(TumblingEventTimeWindows.of(Time.seconds(5)))
      .sum(1)


    counts.print()

    env.execute("WatermarkDemo")

  }

}

### 验证

时间戳：

	2021-08-10 20:10:00 1628597400
	2021-08-10 20:40:00 1628599200
	2021-08-10 20:40:10 1628599210
	

连续输入：

	1,1628597400
	1,1628599200
	
flink侧输出：

	(1,1)
	
### 解释

第一个时间20:10:00 设置20秒的延迟，则是20:10:20， 而20:40:00 远远大于了watermark，则出发啦window。如果没有超过20秒延迟的信息的输入，则会一直卡住，不触发windows。


## forMonotonousTimestamps Demo

单调递增时间戳分配器.

周期性 watermark 生成方式的一个最简单特例就是你给定的数据源中数据的时间戳升序出现。在这种情况下，当前时间戳就可以充当 watermark，因为后续到达数据的时间戳不会比当前的小。


### 代码

	package wzy
	
	
	import org.apache.flink.api.common.eventtime.{SerializableTimestampAssigner, WatermarkStrategy}
	import org.apache.flink.api.scala.createTypeInformation
	import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment
	import org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows
	import org.apache.flink.streaming.api.windowing.time.Time
	
	
	case class Info(text: String, timeRecord: Long)
	
	object WatermarkDemo {
	
	  def main(args: Array[String]): Unit = {
	
	    val env = StreamExecutionEnvironment.getExecutionEnvironment
	    env.setParallelism(1)
	    val text = env.socketTextStream("47.112.142.231", 9999)
	
	    val withTimestampsAndWatermarks = text
	      .assignTimestampsAndWatermarks(WatermarkStrategy.forMonotonousTimestamps()
	        .withTimestampAssigner(new SerializableTimestampAssigner[String] {
	          override def extractTimestamp(t: String, l: Long): Long =
	            t.split(",")(1).toLong * 1000l
	        })
	      )
	
	
	    val counts =withTimestampsAndWatermarks
	      .map(_.split(",")(0))
	      .map { (_, 1) }
	      .keyBy( _._1)
	      .window(TumblingEventTimeWindows.of(Time.seconds(5)))
	      .sum(1)
	
	
	    counts.print()
	
	    env.execute("WatermarkDemo")
	
	  }
	
	}

### 验证

当所有时间程正序的时候，会依次计数

	[root@izwz930tnxht4q6f3yxum6z ~]# nc -l 9999
	1,1628597400
	1,1628599200
	1,1628599210

flink侧输出：
	
	(1,1)
	(1,1)
	
	
当时间不成正序的时候，会抛弃掉错误数据


	[root@izwz930tnxht4q6f3yxum6z ~]# nc -l 9999
	1,1628597400
	1,1628599210
	1,1628599200

flink侧输出：	
	
	(1,1)