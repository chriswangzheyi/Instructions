#18.2 Grapx综合练习

## 代码

	package com.wzy
	
	import org.apache.spark.graphx._
	import org.apache.spark.rdd.RDD
	import org.apache.spark.sql.SparkSession
	
	object SNSAnalysisGraphX extends java.io.Serializable {
	
	  def main(args: Array[String]): Unit = {
	
	    val spark = SparkSession.builder()
	      .appName("spark dataset")
	      .master("spark://192.168.2.123:7077")
	      //本地测试运行需要加这一句话，部署在生产环境则删除
	      .config("spark.jars", "/Users/zheyiwang/IdeaProjects/SparkApps/target/SparkApps-1.0-SNAPSHOT-jar-with-dependencies.jar")
	      .getOrCreate()
	    val sc = spark.sparkContext
	    import spark.implicits._
	
	    //设置顶点和边，注意顶点和边都是用元组定义的Array
	    //顶点的数据类型是VD:(String,Int)
	    val vertexArray = Array(
	      (1L, ("Alice", 28)),
	      (2L, ("Bob", 27)),
	      (3L, ("Charlie", 65)),
	      (4L, ("David", 42)),
	      (5L, ("Ed", 55)),
	      (6L, ("Fran", 50))
	    )
	    //边的数据类型ED:Int
	    val edgeArray = Array(
	      Edge(2L, 1L, 7),
	      Edge(2L, 4L, 2),
	      Edge(3L, 2L, 4),
	      Edge(3L, 6L, 3),
	      Edge(4L, 1L, 1),
	      Edge(5L, 2L, 2),
	      Edge(5L, 3L, 8),
	      Edge(5L, 6L, 3)
	    )
	
	    //构造vertexRDD和edgeRDD
	    val vertexRDD: RDD[(Long, (String, Int))] = sc.parallelize(vertexArray)
	    val edgeRDD: RDD[Edge[Int]] = sc.parallelize(edgeArray)
	
	    //构造图Graph[VD,ED]
	    val graph: Graph[(String, Int), Int] = Graph(vertexRDD, edgeRDD)
	
	    //***************************************************************************************************
	    //*******************************          图的属性          *****************************************
	    //***************************************************************************************************
	    println("**********************************************************")
	    println("属性演示")
	    println("**********************************************************")
	    //方法一
	    println("找出图中年龄大于30的顶点方法一：")
	
	    /**
	     * 其实这里还可以加入性别等信息，例如我们可以看年龄大于30岁且是female的人
	     */
	    graph.vertices.filter { case (id, (name, age)) => age > 30 }.collect.foreach {
	      case (id, (name, age)) => println(s"$name is $age")
	    }
	    //方法二
	    println("找出图中年龄大于30的顶点方法二：")
	    graph.vertices.filter(v => v._2._2 > 30).collect.foreach(v => println(s"${v._2._1} is ${v._2._2}"))
	    println
	
	    //边操作：找出图中属性大于5的边
	    println("找出图中属性大于5的边：")
	    graph.edges.filter(e => e.attr > 5).collect.foreach(e => println(s"${e.srcId} to ${e.dstId} att ${e.attr}"))
	    println
	
	
	    //triplets操作，((srcId, srcAttr), (dstId, dstAttr), attr)
	    println("列出所有的tripltes：")
	    for (triplet <- graph.triplets.collect) {
	      println(s"${triplet.srcAttr._1} likes ${triplet.dstAttr._1}")
	    }
	    println
	
	    println("列出边属性>5的tripltes：")
	    for (triplet <- graph.triplets.filter(t => t.attr > 5).collect) {
	      println(s"${triplet.srcAttr._1} likes ${triplet.dstAttr._1}")
	    }
	    println
	
	    //Degrees操作
	    println("找出图中最大的出度、入度、度数：")
	
	    def max(a: (VertexId, Int), b: (VertexId, Int)): (VertexId, Int) = {
	      if (a._2 > b._2) a else b
	    }
	
	    //解释：graph.outDegrees: (点id，下游点的个数)
	    println("max of outDegrees:" + graph.outDegrees.reduce(max) + " max of inDegrees:" + graph.inDegrees.reduce(max) + " max of Degrees:" + graph.degrees.reduce(max))
	    println
	
	    //***************************************************************************************************
	    //*******************************          转换操作          *****************************************
	    //***************************************************************************************************
	    println("**********************************************************")
	    println("转换操作")
	    println("**********************************************************")
	    println("顶点的转换操作，顶点age + 10：")
	    graph.mapVertices { case (id, (name, age)) => (id, (name, age + 10)) }
	      .vertices.collect.foreach(v => println(s"${v._2._1} is ${v._2._2} 说明：${v._2._2._1} 分区？${v._2._2._2}"))
	
	    println
	    println("边的转换操作，边的属性*2：")
	    graph.mapEdges(e =>  e.attr * 2).edges.collect.foreach(e => println(s"${e.srcId} to ${e.dstId} att ${e.attr}"))
	    println
	
	    //***************************************************************************************************
	    //*******************************          结构操作          *****************************************
	    //***************************************************************************************************
	    println("**********************************************************")
	    println("结构操作")
	    println("**********************************************************")
	    println("顶点年纪>30的子图：")
	    val subGraph: Graph[(String, PartitionID), PartitionID] = graph.subgraph(vpred = (id, vd) => vd._2 >= 30)
	    println("子图所有顶点：")
	    subGraph.vertices.collect.foreach(v => println(s"${v._2._1} is ${v._2._2}"))
	
	    println
	    println("子图所有边：")
	    subGraph.edges.collect.foreach(e => println(s"${e.srcId} to ${e.dstId} att ${e.attr}"))
	    println
	
	    //***************************************************************************************************
	    //*******************************          连接操作          *****************************************
	    //***************************************************************************************************
	    println("**********************************************************")
	    println("连接操作")
	    println("**********************************************************")
	    val inDegrees: VertexRDD[Int] = graph.inDegrees
	
	    case class User(name: String, age: Int, inDeg: Int, outDeg: Int)
	
	    //创建一个新图，顶点VD的数据类型为User，并从graph做类型转换
	    val initialUserGraph: Graph[User, Int] = graph.mapVertices { case (id, (name, age)) => User(name, age, 0, 0) }
	    //initialUserGraph与inDegrees、outDegrees（RDD）进行连接，并修改initialUserGraph中inDeg值、outDeg值
	    val userGraph: Graph[User, PartitionID] = initialUserGraph.outerJoinVertices(initialUserGraph.inDegrees) {
	      case (id, u, inDegOpt) => User(u.name, u.age, inDegOpt.getOrElse(0), u.outDeg)
	    }.outerJoinVertices(initialUserGraph.outDegrees) {
	      case (id, u, outDegOpt) => User(u.name, u.age, u.inDeg, outDegOpt.getOrElse(0))
	    }
	    println("连接图的属性：")
	    userGraph.vertices.collect.foreach(v => println(s"${v._2.name} inDeg: ${v._2.inDeg}  outDeg: ${v._2.outDeg}"))
	    println
	
	    println("出度和入读相同的人员：")
	    userGraph.vertices.filter {
	      case (id, u) => u.inDeg == u.outDeg
	    }.collect.foreach {
	      case (id, property) => println(property.name)
	    }
	    println
	
	
	    println("**********************************************************")
	    println("聚合操作")
	    println("**********************************************************")
	    println("找出年纪最大的追求者：")
	    val oldestFollower: VertexRDD[(String, Int)] = graph.aggregateMessages[(String, Int)](
	      // 将源顶点的属性发送给目标顶点，map过程
	      triplet => {
	        triplet.sendToDst(triplet.srcAttr._1, triplet.srcAttr._2)
	      },
	      // 得到最大追求者，reduce过程
	      (a, b) => if (a._2 > b._2) a else b
	    )
	    userGraph.vertices.leftJoin(oldestFollower) { (id, user, optOldestFollower) => {
	      optOldestFollower match {
	        case None => s"${user.name} does not have any followers."
	        case Some((name, age)) => s"${name} is the oldest follower of ${user.name}."
	      }
	    }
	    }
	
	    userGraph.vertices.leftJoin(oldestFollower) { (id, user, optOldestFollower) => {
	      optOldestFollower match {
	        case None => s"${user.name} does not have any followers."
	        case Some((name, age)) => s"${name} is the oldest follower of ${user.name}."
	      }
	    }
	    }.collect.foreach { case (id, str) => println(str) }
	    println
	
	
	  }
	}



## 打印

	**********************************************************
	属性演示
	**********************************************************
	找出图中年龄大于30的顶点方法一：
	David is 42
	Fran is 50
	Charlie is 65
	Ed is 55
	找出图中年龄大于30的顶点方法二：
	David is 42
	Fran is 50
	Charlie is 65
	Ed is 55
	
	找出图中属性大于5的边：
	2 to 1 att 7
	5 to 3 att 8
	
	列出所有的tripltes：
	Bob likes Alice
	Bob likes David
	Charlie likes Bob
	Charlie likes Fran
	David likes Alice
	Ed likes Bob
	Ed likes Charlie
	Ed likes Fran
	
	列出边属性>5的tripltes
	Bob likes Alice
	Ed likes Charlie
	
	找出图中最大的出度、入度、度数：
	max of outDegrees:(5,3) max of inDegrees:(2,2) max of Degrees:(2,4)
	
	**********************************************************
	转换操作
	**********************************************************
	顶点的转换操作，顶点age + 10：
	4 is (David,52) 说明：David 分区？52
	6 is (Fran,60) 说明：Fran 分区？60
	2 is (Bob,37) 说明：Bob 分区？37
	1 is (Alice,38) 说明：Alice 分区？38
	3 is (Charlie,75) 说明：Charlie 分区？75
	5 is (Ed,65) 说明：Ed 分区？65
	
	边的转换操作，边的属性*2：
	2 to 1 att 14
	2 to 4 att 4
	3 to 2 att 8
	3 to 6 att 6
	4 to 1 att 2
	5 to 2 att 4
	5 to 3 att 16
	5 to 6 att 6
	
	**********************************************************
	结构操作
	**********************************************************
	顶点年纪>30的子图：
	子图所有顶点：
	David is 42
	Fran is 50
	Charlie is 65
	Ed is 55
	
	子图所有边：
	3 to 6 att 3
	5 to 3 att 8
	5 to 6 att 3
	
	**********************************************************
	连接操作
	**********************************************************
	连接图的属性：
	David inDeg: 1  outDeg: 1
	Fran inDeg: 2  outDeg: 0
	Bob inDeg: 2  outDeg: 2
	Alice inDeg: 2  outDeg: 0
	Charlie inDeg: 1  outDeg: 2
	Ed inDeg: 0  outDeg: 3
	
	出度和入读相同的人员：
	David
	Bob
	
	**********************************************************
	聚合操作
	**********************************************************
	找出年纪最大的追求者：
	Bob is the oldest follower of David.
	Charlie is the oldest follower of Fran.
	Charlie is the oldest follower of Bob.
	David is the oldest follower of Alice.
	Ed is the oldest follower of Charlie.
	Ed does not have any followers.