#房价预测

## 分析步骤

### 分析是否满足内存要求

	import pandas as pd
	
	housing = pd.read_csv('E:\housing/housing.csv')
	
	print(housing.info())

输出：

	<class 'pandas.core.frame.DataFrame'>
	RangeIndex: 20640 entries, 0 to 20639
	Data columns (total 10 columns):
	longitude             20640 non-null float64
	latitude              20640 non-null float64
	housing_median_age    20640 non-null float64
	total_rooms           20640 non-null float64
	total_bedrooms        20433 non-null float64
	population            20640 non-null float64
	households            20640 non-null float64
	median_income         20640 non-null float64
	median_house_value    20640 non-null float64
	ocean_proximity       20640 non-null object
	dtypes: float64(9), object(1)
	memory usage: 1.6+ MB
	None

分析memory usage来判断内存是否满足

non-null： 表示没有空项目

#### 分析数据情况
	
	import pandas as pd
	import matplotlib.pyplot as plt
	housing = pd.read_csv('E:\housing/housing.csv')
	
	print(housing.describe())
	housing = pd.read_csv('E:\housing/housing.csv')
	housing.hist(bins=50, figsize=(29,15))
	plt.show()

输出：

	          longitude      latitude  ...  median_income  median_house_value
	count  20640.000000  20640.000000  ...   20640.000000        20640.000000
	mean    -119.569704     35.631861  ...       3.870671       206855.816909
	std        2.003532      2.135952  ...       1.899822       115395.615874
	min     -124.350000     32.540000  ...       0.499900        14999.000000
	25%     -121.800000     33.930000  ...       2.563400       119600.000000
	50%     -118.490000     34.260000  ...       3.534800       179700.000000
	75%     -118.010000     37.710000  ...       4.743250       264725.000000
	max     -114.310000     41.950000  ...      15.000100       500001.000000


std： 表示方差。方差过大则需要注意是否有异常数据。需要在建模的时候处理


![](../Images/1.png)

从图上可以先了解一下数据的一个分布情况


#### 根据地理信息可视化


	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	# 根据经纬度找规律
	housing_train = strat_train_set.copy()
	housing_train.plot(kind="scatter", x="longitude",y="latitude", alpha =0.1,
	                   s = housing.population/100, label= "polulation",figsize =(10,7),
	                   c = "polulation", cmap = plt.get_cmap('jet'), colorbar=True,
	                   sharex= False
	                   )
	# s =  scalar 标量值。 housing.population/100 因为人口数量比较多，数字太大影响效果，所以除以100
	# c：颜色
	# cmap = plt.get_cmap('jet') 设置渐变色
	# sharex ： 设置是否需要共享x
	
	plt.show()


![](../Images/2.png)

上图是地图，每一个点代表一个房产。


#### 数据相关性（单个）


	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	# 查看数据之间的关系
	corr_matrix = housing.corr()
	relation = corr_matrix.median_house_value.sort_values(ascending= False)
	print(relation)


输出：

	median_house_value    1.000000
	median_income         0.688075
	income_cat            0.643892
	total_rooms           0.134153
	housing_median_age    0.105623
	households            0.065843
	total_bedrooms        0.049686
	population           -0.024650
	longitude            -0.045967
	latitude             -0.144160
	Name: median_house_value, dtype: float64

上面的例子以median_house_value为例，查看各个数据特征之间的关系。  **co-relation的范围是-1 到 1 。 1为相关， -1为负相关**。


#### 数据相关性（多个）

	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	from pandas.plotting import  scatter_matrix
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	#多个要素
	attributes = ["median_house_value","median_income","total_rooms","housing_median_age"]
	scatter_matrix(housing[attributes],figsize=(12,8))
	plt.show()


![](../Images/3.png)

可以从图上看出规律。


#### 特征工程

特征工程是指按照业务需要可以自己造数据要素

	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	from pandas.plotting import  scatter_matrix
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	# 特征工程
	housing["roons_per_household"] =housing.total_rooms/housing.households #家庭平均房间数
	housing["bedrooms_per_room"] = housing.total_bedrooms/housing.total_rooms # 卧室占比
	housing["population_per_household"] = housing.population/housing.households # 家庭平均人数
	
	#计算相关性
	corr_matrix = housing.corr()
	relation = corr_matrix.median_house_value.sort_values(ascending=False)
	print(relation)
	

输出：

	median_house_value          1.000000
	median_income               0.688075
	income_cat                  0.643892
	roons_per_household         0.151948
	total_rooms                 0.134153
	housing_median_age          0.105623
	households                  0.065843
	total_bedrooms              0.049686
	population_per_household   -0.023737
	population                 -0.024650
	longitude                  -0.045967
	latitude                   -0.144160
	bedrooms_per_room          -0.255880
	Name: median_house_value, dtype: float64

#### 数据标签

将验证集的数据分为两部分：x和y。x是数据特征，y是预测数据。

	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	from pandas.plotting import  scatter_matrix
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	# 特征工程
	housing["roons_per_household"] =housing.total_rooms/housing.households #家庭平均房间数
	housing["bedrooms_per_room"] = housing.total_bedrooms/housing.total_rooms # 卧室占比
	housing["population_per_household"] = housing.population/housing.households # 家庭平均人数
	
	#s数据和标签
	housing = strat_test_set.drop("median_house_value",axis=1) #数据特征
	housing_labels = strat_test_set.median_house_value.copy() #预测数据


#### 数据清洗

常见有两种方法：1.直接删除有空值的行， 2，用中位数填充。 推荐使用中位数方法

	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	from pandas.plotting import  scatter_matrix
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	# 特征工程
	housing["roons_per_household"] =housing.total_rooms/housing.households #家庭平均房间数
	housing["bedrooms_per_room"] = housing.total_bedrooms/housing.total_rooms # 卧室占比
	housing["population_per_household"] = housing.population/housing.households # 家庭平均人数
	
	#s数据和标签
	housing = strat_test_set.drop("median_house_value",axis=1)
	housing_labels = strat_test_set.median_house_value.copy()
	
	# 数据清洗
	## 方法一：删掉所有空值的列,使用dropna()方法
	
	## 方法二：用中位数填充空值
	median = housing.total_bedrooms.median()
	housing_clean = housing.copy()
	housing_clean.total_bedrooms.fillna(median,inplace=True)
	
	## 其他操作： 将不能处理的行drop掉
	housing_clean = housing_clean.drop('ocean_proximity',axis=1)



#### 文本清理

文本类的数据无法放在模型中，需要处理为数字。以ocean_proximity参数为例：

	print(housing_clean.ocean_proximity.value_counts() )

得到

	<1H OCEAN     1860
	INLAND        1288
	NEAR OCEAN     534
	NEAR BAY       443
	ISLAND           3


使用One-hot 独占码，将文本类种类分为数字

	import pandas as pd
	import numpy as np
	import matplotlib.pyplot as plt
	from sklearn.model_selection import train_test_split, StratifiedKFold, StratifiedShuffleSplit
	from pandas.plotting import  scatter_matrix
	from sklearn.preprocessing import  OneHotEncoder
	
	# 导入数据
	housing = pd.read_csv('E:\housing/housing.csv')
	
	# 根据重要特征分离数据
	housing['income_cat'] = np.ceil(housing.median_income/1.5) # 将分布变得更加集中
	housing.income_cat.where(housing.income_cat<5, 5, inplace=True)  # 将小于5的保留，大于等于5的分为一类
	
	# 分离数据
	split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
	
	# 按照 housing.income_cat为比例，分离数据为测试集和训练集
	for train_index, test_index in split.split(housing, housing.income_cat):  #
	    strat_train_set = housing.loc[train_index]
	    strat_test_set = housing.loc[test_index]
	
	# 因为housing.income_cat是一个临时引入的比例，不是数据，所以需要在数据分离后去掉
	for set_ in (strat_train_set,strat_test_set):
	    set_.drop("income_cat",axis=1, inplace= True)
	
	
	# 特征工程
	housing["roons_per_household"] =housing.total_rooms/housing.households #家庭平均房间数
	housing["bedrooms_per_room"] = housing.total_bedrooms/housing.total_rooms # 卧室占比
	housing["population_per_household"] = housing.population/housing.households # 家庭平均人数
	
	#s数据和标签
	housing = strat_test_set.drop("median_house_value",axis=1)
	housing_labels = strat_test_set.median_house_value.copy()
	
	# 数据清洗
	## 方法一：删掉所有空值的列,使用dropna()方法
	
	## 方法二：用中位数填充空值
	median = housing.total_bedrooms.median()
	housing_clean = housing.copy()
	housing_clean.total_bedrooms.fillna(median,inplace=True)
	
	## 数据清洗之文本处理、
	
	### 将文本分成[0,1,0...]等one-hot独热码
	housing_cat = housing.ocean_proximity
	housing_cat_encoded, housing_categories = housing_cat.factorize()
	encoder = OneHotEncoder(categories='auto')
	housing_cat_1hot=encoder.fit_transform(housing_cat_encoded.reshape(-1,1))  # （-1.1）表示行不知道，列为1









