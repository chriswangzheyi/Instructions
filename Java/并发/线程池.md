# 线程池

## ThreadPoolExecutor 构造方法


	   public ThreadPoolExecutor(int corePoolSize,
	                              int maximumPoolSize,
	                              long keepAliveTime,
	                              TimeUnit unit,
	                              BlockingQueue<Runnable> workQueue,
	                              ThreadFactory threadFactory,
	                              RejectedExecutionHandler handler)



**corePoolSize：**核心线程池大小。

**maximumPoolSize：**线程池中最大的存活线程数

**keepAliveTime：**超时时间

**unit:**超时时间的单位，秒，毫秒，微秒，纳秒等

**workQueue：**当调用execute方法时，如果线程池中没有空闲的可用线程，那么就会把这个Runnable对象放到该队列中。这个参数必须是一个实现BlockingQueue接口的阻塞队列，因为要保证线程安全。

**threadFactory：**线程工厂类。用于在需要的时候生成新的线程。默认实现是Executors.defaultThreadFactory()

**handler：**这个参数的作用是当提交任务时既没有空闲线程，任务队列也满了，这时候就会调用handler的rejectedExecution方法。默认的实现是抛出一个RejectedExecutionException异常。


### 例子

	import java.util.concurrent.*;
	
	public class ThreadPoolExcutorDemo {
	
	    private static ExecutorService pool;
	
	    public static void main(String[] args) {
	
	        pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
	
	        for(int i=0;i<3;i++) {
	            pool.submit(new ThreadTask());
	        }
	    }
	
	}
	
	class ThreadTask implements Runnable {
	
	    public ThreadTask() {
	
	    }
	
	    public void run() {
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


### 运行结果

	pool-1-thread-2
	pool-1-thread-1
	Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@6d6f6e28 rejected from java.util.concurrent.ThreadPoolExecutor@135fbaa4[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
		at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
		at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
		at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
		at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
		at ThreadPoolExcutorDemo.main(ThreadPoolExcutorDemo.java:12)

可以看到只有2个线程被运行，剩余的被抛异常了。

## Executors创建线程池

Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可

![](../Images/2.png)

### newCachedThreadPool


创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newCachedThreadPool();
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


#### 输出结果：

	pool-1-thread-6
	pool-1-thread-3
	pool-1-thread-4
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-5
	pool-1-thread-7
	pool-1-thread-8
	pool-1-thread-9
	pool-1-thread-10

任务被立即执行了

### newFixedThreadPool

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newFixedThreadPool(2);
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


#### 输出结果

	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-1
	pool-1-thread-2

每次执行2个线程


### newSingleThreadExecutor

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newSingleThreadExecutor();
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}

## newScheduledThreadPool

定时执行任务

	import java.util.concurrent.Executors;
	import java.util.concurrent.ScheduledExecutorService;
	import java.util.concurrent.TimeUnit;
	
	public class ScheduleTask {
	
	    public static void main(String[] args) {
	
	        ScheduledExecutorService pool = Executors.newScheduledThreadPool(5);
	
	        //延迟2秒执行一次
	        pool.schedule(new Runnable() {
	            @Override
	            public void run() {
	                System.out.println("延迟两秒执行一次");
	            }
	        }, 2, TimeUnit.SECONDS);
	
	    }
	
	}


## FutureTask

FutureTask就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。该方法会阻塞直到任务返回结果


	import java.util.concurrent.*;
	
	public class FutureTaskTest {
	
	    public static void main(String[] args) {
	
	        ExecutorService executor = Executors.newCachedThreadPool();
	        //进行异步计算
	        Task task = new Task();
	        //获取异步计算结果
	        Future<Integer> result = executor.submit(task);
	        executor.shutdown();
	
	        try {
	            System.out.println("task运行结果"+result.get());
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        } catch (ExecutionException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println("所有任务执行完毕");
	
	    }
	
	}
	
	class Task implements Callable<Integer> {
	
	    @Override
	    public Integer call() throws Exception {
	
	        System.out.println("子线程在进行计算");
	        Thread.sleep(3000);
	        int sum = 0;
	        for(int i=0;i<100;i++)
	            sum += i;
	        return sum;
	
	    }
	
	}


执行的时候可以观察到，主线程在等待子线程执行完毕后才会往下运行。


## 如何合理地配置线程池

分析维度：

(1) 任务的性质： CPU密集型任务、IO密集型任务还是混合型任务。

(2) 任务的优先级： 高、中、低

(3) 任务执行时间： 长、中、短

(4) 任务的依赖性：是否依赖其他系统资源、如数据库连接


## RejectedExecutionHandler 线程池四种拒绝任务策略



1、直接丢弃（DiscardPolicy）

2、丢弃队列中最老的任务(DiscardOldestPolicy)。

3、抛异常(AbortPolicy)

4、将任务分给调用线程来执行(CallerRunsPolicy)。