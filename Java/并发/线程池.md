# 线程池

## ThreadPoolExecutor 构造方法


	   public ThreadPoolExecutor(int corePoolSize,
	                              int maximumPoolSize,
	                              long keepAliveTime,
	                              TimeUnit unit,
	                              BlockingQueue<Runnable> workQueue,
	                              ThreadFactory threadFactory,
	                              RejectedExecutionHandler handler)



**corePoolSize：**核心线程池大小。

**maximumPoolSize：**线程池中最大的存活线程数

**keepAliveTime：**超时时间

**unit:**超时时间的单位，秒，毫秒，微秒，纳秒等

**workQueue：**当调用execute方法时，如果线程池中没有空闲的可用线程，那么就会把这个Runnable对象放到该队列中。这个参数必须是一个实现BlockingQueue接口的阻塞队列，因为要保证线程安全。

**threadFactory：**线程工厂类。用于在需要的时候生成新的线程。默认实现是Executors.defaultThreadFactory()

**handler：**这个参数的作用是当提交任务时既没有空闲线程，任务队列也满了，这时候就会调用handler的rejectedExecution方法。默认的实现是抛出一个RejectedExecutionException异常。


### 例子

	import java.util.concurrent.*;
	
	public class ThreadPoolExcutorDemo {
	
	    private static ExecutorService pool;
	
	    public static void main(String[] args) {
	
	        pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
	
	        for(int i=0;i<3;i++) {
	            pool.submit(new ThreadTask());
	        }
	    }
	
	}
	
	class ThreadTask implements Runnable {
	
	    public ThreadTask() {
	
	    }
	
	    public void run() {
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


### 运行结果

	pool-1-thread-2
	pool-1-thread-1
	Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@6d6f6e28 rejected from java.util.concurrent.ThreadPoolExecutor@135fbaa4[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
		at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
		at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
		at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
		at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
		at ThreadPoolExcutorDemo.main(ThreadPoolExcutorDemo.java:12)

可以看到只有2个线程被运行，剩余的被抛异常了。

## Executors创建线程池

Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可

![](../Images/2.png)

### newCachedThreadPool

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newCachedThreadPool();
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


#### 输出结果：

	pool-1-thread-6
	pool-1-thread-3
	pool-1-thread-4
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-5
	pool-1-thread-7
	pool-1-thread-8
	pool-1-thread-9
	pool-1-thread-10

任务被立即执行了

### newFixedThreadPool

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newFixedThreadPool(2);
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}


#### 输出结果

	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-2
	pool-1-thread-1
	pool-1-thread-1
	pool-1-thread-2

每次执行2个线程


### newSingleThreadExecutor

	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class ExcutorsDemo {
	
	    public static void main(String[] args) {
	
	    ExecutorService pool = Executors.newSingleThreadExecutor();
	
	        for (int i =0; i<10;i++){
	            pool.submit(new ThreadTasks());
	        }
	
	     pool.shutdown();
	
	    }
	}
	
	
	class ThreadTasks implements Runnable {
	
	    public ThreadTasks() {
	
	    }
	
	    public void run() {
	
	        try {
	            Thread.sleep(2000);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	
	        System.out.println(Thread.currentThread().getName());
	    }
	
	}



## 如何合理地配置线程池

分析维度：

(1) 任务的性质： CPU密集型任务、IO密集型任务还是混合型任务。

(2) 任务的优先级： 高、中、低

(3) 任务执行时间： 长、中、短

(4) 任务的依赖性：是否依赖其他系统资源、如数据库连接

(5)