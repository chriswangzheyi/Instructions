# HashMap的工作原理-hashcode和equals的区别

先来试想一个场景，如果你想查找一个集合中是否包含某个对象，那么程序应该怎么写呢？通常的做法是逐一取出每个元素与要查找的对象一一比较，当发现两者进行equals比较结果相等时，则停止查找并返回true，否则，返回false。但是这个做法的一个缺点是当集合中的元素很多时，譬如有一万个元素，那么逐一的比较效率势必下降很快。于是有人发明了一种哈希算法来提高从该集合中查找元素的效率，这种方式将集合分成若干个存储区域（可以看成一个个桶），每个对象可以计算出一个哈希码，可以根据哈希码分组，每组分别对应某个存储区域，这样一个对象根据它的哈希码就可以分到不同的存储区域（不同的桶中）。如下图所示：

![](../Images/1.png)

的hashCode值存储在不同的存储区域中了，那么现在查找某个对象（根据对象的key来查找），不需要遍历整个集合了，现在只需要计算要查找对象的key的hashCode，然后找到该hashCode对应的存储区域，在该存储区域中来查找就可以了，这样效率也就提升了很多。说了这么多相信你对hashCode的作用有了一定的了解，下面就来看看hashCode和equals的区别和联系。

在研究这个问题之前，首先说明一下JDK对equals(Object obj)和hashCode()这两个方法的定义和规范：在Java中任何一个对象都具备equals(Object obj)和hashCode()这两个方法，因为他们是在Object类中定义的。 equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。 hashCode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。 

