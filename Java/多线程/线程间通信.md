# 线程间通信

参考资料： https://www.cnblogs.com/linyufeng/p/9671844.html

## 使用 volatile 关键字

两个线程通过volatile关键字获取信息

	public class myVolitileDemo {
	
	    private static volatile int num = 0;
	
	    public static void main(String[] args) {
	
	
	        Thread thread1 = new Thread(new Runnable() {
	            @Override
	            public void run() {
	                
	                System.out.println("线程1的数字"+num);
	                num++;
	            }
	        });
	
	
	        Thread thread2 = new Thread(new Runnable() {
	            @Override
	            public void run() {
	
	                try {
	                    Thread.sleep(2000);
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                }
	
	                System.out.println("线程2的数字"+num);
	                num++;
	            }
	        });
	
	
	        thread1.start();
	        thread2.start();
	    }
	}



## 使用Object类的wait() 和 notify() 方法

两个线程交替获得锁

	public class myWaitAndNotify {
	
	
	    private static Object lock = new Object();
	    private static boolean flag =true;
	    private static int counter = 0 ;
	
	    public static void main(String[] args) {
	
	
	        Thread thread1 = new Thread(new Runnable() {
	            @Override
	            public void run() {
	
	                while (counter < 10) {
	
	                    if (flag == true) {
	                        synchronized (lock) {
	                            System.out.println(counter+" --- 线程1 拿到锁");
	                            flag = false;
	                            counter++;
	                            lock.notify();
	                        }
	
	                    }
	                }
	            }
	
	        });
	
	
	        Thread thread2 = new Thread(new Runnable() {
	            @Override
	            public void run() {
	
	                while (counter < 10) {
	                    if (flag == false) {
	                        synchronized (lock) {
	                            System.out.println(counter+" --- 线程2 拿到锁");
	                            flag = true;
	                            counter++;
	                            lock.notify();
	                        }
	                    }
	                }
	            }
	        });
	
	
	        thread1.start();
	        thread2.start();
	
	
	    }
	}




## 使用JUC工具类 CountDownLatch

CountDownLatch可以代替wait/notify的使用,并去掉synchronized。countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次。


类中有三个方法是最重要的：

	//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
	public void await() throws InterruptedException { };   

	//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
	public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  

	//将count值减1
	public void countDown() { };  

例子：



	import java.util.concurrent.CountDownLatch;
	import java.util.concurrent.ExecutorService;
	import java.util.concurrent.Executors;
	
	public class CountDownLatchTest {
	
	    public static void main(String[] args) {
	        final CountDownLatch latch = new CountDownLatch(2);
	        System.out.println("主线程开始执行…… ……");
	        //第一个子线程执行
	        ExecutorService es1 = Executors.newSingleThreadExecutor();
	        es1.execute(new Runnable() {
	            @Override
	            public void run() {
	                try {
	                    Thread.sleep(3000);
	                    System.out.println("子线程："+Thread.currentThread().getName()+"执行");
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                }
	                latch.countDown();
	            }
	        });
	        es1.shutdown();
	
	        //第二个子线程执行
	        ExecutorService es2 = Executors.newSingleThreadExecutor();
	        es2.execute(new Runnable() {
	            @Override
	            public void run() {
	                try {
	                    Thread.sleep(3000);
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                }
	                System.out.println("子线程："+Thread.currentThread().getName()+"执行");
	                latch.countDown();
	            }
	        });
	        es2.shutdown();
	        System.out.println("等待两个线程执行完毕…… ……");
	        try {
	            latch.await();
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	        System.out.println("两个子线程都执行完毕，继续执行主线程");
	    }
	}


## 使用工具 CyclicBarrier

CyclicBarrier 跟 CountDownLatch 

CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用