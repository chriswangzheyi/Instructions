#响应式流 Reactive Stream


**发布-订阅(publisher-subscriber)框架**

Java 9 通过java.util.concurrent.Flow 和java.util.concurrent.SubmissionPublisher 类来实现响应式流。

Flow 类中定义了四个嵌套的静态接口，用于建立流量控制的组件，发布者在其中生成一个或多个供订阅者使用的数据项：


- Publisher：数据项发布者、生产者
- Subscriber：数据项订阅者、消费者
- Subscription：发布者与订阅者之间的关系纽带，订阅令牌
- Processor：数据处理器


发布者(Publisher)以流的方式发布数据项，并注册订阅者，并且实现 Flow.Publisher 接口，该接口声明了一个方法，我们通过调用它来为发布者注册订阅者：

    void subscribe(Flow.Subscriber<? super T> subscriber)

调用此方法来向发布者注册订阅者，但是，如果此订阅者已被其他发布者注册或注册失败(策略冲突)，这个方法就会调用订阅者的onError() 方法来抛出IllegalStateException 异常，除此之外，订阅者的onSubscribe() 方法会调用一个新的Flow.Subscription ，当空对象传给订阅者时，subscribe() 方法会抛出NullPointerException异常。

---

订阅者(Subscriber)从订阅的发布者中返回数据项，并且实现Flow.Subscriber<T> ，这个接口声明的方法如下：

- void onSubscribe(Flow.Subscription subscription)
- void onComplete()
- void onError(Throwable throwable)
- void onNext(T item)

**onSubscribe()** 方法用来确认订阅者注册到发布者是否注册成功，它以参数列表的方式接收一个Flow.Subscription类型的参数，而这个参数类型里面声明的方法允许向发布者请求发布新的数据项，或请求发布者不再发布更多的数据项。

**onComplete()** 方法用在当订阅者没有调用其他方法，而Subscription 发生错误没有终止的情况下。调用这个方法之后，此订阅者就不能调用其他方法。

**onError(Throwable throwable)** 方法用在当发布者或订阅者遭遇不可恢复的错误的时候， 调用这个方法之后，此订阅者也不能调用其他方法。

**onNext()** 方法用于声明下一个数据项的订阅，如果在此过程中抛出异常，结果将得不到确认，甚至会导致订阅被取消。

---

**一个订阅令牌(Subscription)**为发布者和订阅者定义一种关系， 使得订阅者接收特定的数据项或者在特定时间取消接收请求，订阅令牌实现自Flow.Subscription 接口，该接口声明方法如下：

	void request(long n)
	void cancel()

- request() 方法添加n个数据项到当前未满的订阅请求中。如果n小于或等于0，订阅者的onError() 方法会被调用，并且抛出IllegalArgumentException 异常，此外，如果n大于0，订阅者就会在onNext() 方法的调用下接收到n个数据项，除非中间异常终止。 从Long.MAX_VALUE次到n次中间是无界的调用。

- cancel() 用来终止订阅者接收数据项，它有一种尝试机制，也就是说，在调用它之后也有可能收到数据项。

最后，数据处理器(Processor)在不改变发布者与订阅者的情况下基于流做数据处理，可以在发布者与订阅者之间放多个数据处理器，成为一个处理器链，发布者与订阅者不依赖于数据处理，它们是单独的过程。JDK9中不提供具体的数据处理器，必须由开发者来通过实现无方法声明的Processor接口来自行构建。

SubmissionPublisher 实现自Flow.Publisher 接口，向当前订阅者异步提交非空的数据项，直到它被关闭。每个当前订阅者以一个相同的顺序接收新提交的数据项，除非数据项丢失或者遇到异常。SubmissionPublisher 允许数据项在丢失或阻塞的时候扮演发布者角色。

SubmissionPublisher 提供了三个构造方法来获取实例。无参的构造器依赖于 ForkJoinPool.commonPool() 方法来提交发布者，以此实现生产者向订阅者提供数据项的异步特性。



## Demo


	import java.util.Arrays;
	
	import java.util.concurrent.Flow.*;
	import java.util.concurrent.SubmissionPublisher;
	
	public class FlowDemo
	{
	    public static void main(String[] args)
	    {
	        // Create a publisher.
	
	        SubmissionPublisher<String> publisher = new SubmissionPublisher<>();
	
	        // Create a subscriber and register it with the publisher.
	
	        MySubscriber<String> subscriber = new MySubscriber<>();
	        publisher.subscribe(subscriber);
	
	        // Publish several data items and then close the publisher.
	
	        System.out.println("Publishing data items...");
	        String[] items = { "jan", "feb", "mar", "apr", "may", "jun",
	                "jul", "aug", "sep", "oct", "nov", "dec" };
	        Arrays.asList(items).stream().forEach(i -> publisher.submit(i));
	        publisher.close();
	
	        try
	        {
	            synchronized("A")
	            {
	                "A".wait();
	            }
	        }
	        catch (InterruptedException ie)
	        {
	        }
	    }
	}
	
	class MySubscriber<T> implements Subscriber<T>
	{
	    private Subscription subscription;
	
	    @Override
	    public void onSubscribe(Subscription subscription)
	    {
	        this.subscription = subscription;
	        subscription.request(1);
	    }
	
	    @Override
	    public void onNext(T item)
	    {
	        System.out.println("Received: " + item);
	        subscription.request(1);
	    }
	
	    @Override
	    public void onError(Throwable t)
	    {
	        t.printStackTrace();
	        synchronized("A")
	        {
	            "A".notifyAll();
	        }
	    }
	
	    @Override
	    public void onComplete()
	    {
	        System.out.println("Done");
	        synchronized("A")
	        {
	            "A".notifyAll();
	        }
	    }
	}
