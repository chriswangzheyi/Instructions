# LangGraph



## 定义

**LangGraph** 是 LangChain 团队推出的下一代框架，用于构建 **“可控、可观测、可回溯”的 LLM 应用执行图（Graph）**。

它在理念上继承 LangChain，但在架构上做了革命性升级——

> 从“链式执行（Chains）” → “图式执行（Graphs）”。

LangGraph 允许开发者用 **有向图（Directed Graph）** 的形式定义 LLM 工作流，
 让 AI Agent 不再是黑箱，而是一个**可可视化、可控制的推理过程**。



## LangGraph 的设计理念



| 设计目标                         | 说明                                      |
| -------------------------------- | ----------------------------------------- |
| **结构化推理流**                 | 用节点（Node）和边（Edge）描述执行逻辑    |
| **状态驱动（Stateful）**         | 支持对话记忆、上下文状态、外部信息共享    |
| **可观测性（Observability）**    | 与 LangSmith 集成，追踪执行路径与中间变量 |
| **可恢复性（Recoverability）**   | 出错节点可重新执行，无需重跑全程          |
| **多 Agent 协作（Multi-Agent）** | 每个节点可封装一个 Agent，形成复杂协作图  |



## LangGraph 的核心概念

LangGraph 的运行逻辑基于 **状态机（State Machine）** 思想。它定义了几个核心元素：



| 概念                      | 作用                                           | 类比（LangChain 对应） |
| ------------------------- | ---------------------------------------------- | ---------------------- |
| **Node（节点）**          | 单个计算或逻辑单元，可是 LLM、Tool、判断、函数 | Chain 或 Step          |
| **Edge（边）**            | 控制节点之间的执行流向，可带条件或分支         | Chain link             |
| **State（状态）**         | 全局上下文，保存变量、记忆、输出               | Memory                 |
| **Graph（图）**           | 整个工作流的结构定义，节点 + 边                | Chain 集合             |
| **Executor（执行器）**    | 驱动整个图运行的调度器                         | Chain.run()            |
| **Checkpoints（检查点）** | 保存状态快照，可回溯或恢复                     | Callback/Memory        |
| **Streaming（流式执行）** | 支持边生成边处理（特别适合对话）               | Stream callbacks       |



## 什么是 State

在 LangGraph 中，**State（状态）** 是贯穿整个图执行的“上下文容器”。
 它负责保存：

- 输入参数；
- 中间结果；
- 工具调用的反馈；
- 记忆（Memory）；
- 当前任务执行位置；
- 甚至是整个 Agent 的内部变量。

简单地说，**State 是多节点之间传递信息的桥梁**。



## LangGraph 的执行流程

可以理解为一个**有状态的对话与任务流程图**：

```
Start → 用户输入节点
     → 推理节点（LLM）
     → 工具调用节点（Tool）
     → 条件判断边（If Edge）
     → 下一个节点（Next LLM）
     → 最终输出节点（End）
```

每次执行时：

- 系统从入口节点开始；
- 根据边条件动态选择下一个节点；
- 持续更新 State（全局变量）；
- 支持异常回溯、重试、流式更新。





## LangGraph vs LangChain 对比



| 对比维度 | LangChain         | LangGraph                 |
| -------- | ----------------- | ------------------------- |
| 执行结构 | 线性链式（Chain） | 有向图式（Graph）         |
| 控制流   | 顺序执行          | 支持分支、循环、条件流    |
| 状态管理 | 依赖 Memory       | 全局 State 自动传递       |
| 调试追踪 | 基础 Callback     | 完整追踪、回放、检查点    |
| 并发执行 | 支持有限          | 支持并行节点              |
| 典型场景 | 单 Agent 应用     | 多 Agent 协作、任务流管理 |



## LangGraph 与多 Agent 系统

LangGraph 特别适合构建 **多智能体系统（Multi-Agent System）**：

- 每个 Node 代表一个 Agent（如：检索 Agent、总结 Agent、规划 Agent）；
- Edge 表示通信与协作；
- State 是共享的上下文（如会话、任务计划）；
- Graph Executor 调度不同 Agent 的执行。

应用示例：

- **AI 法律助理系统**：检索法条 → 案例比对 → 生成论述；
- **AI 旅行规划系统**：景点检索 → 路线生成 → 价格计算 → 输出计划；
- **AI 代码审查系统**：静态分析 Agent → 安全检测 Agent → 修复建议 Agent。



## LangGraph 的局限与挑战



| 问题                 | 说明                    |
| -------------------- | ----------------------- |
| 开发复杂度较高       | 需要理解状态机模型      |
| 初学者门槛高         | 不如 LangChain “傻瓜式” |
| 文档生态仍在建设     | 更新快、版本差异大      |
| 调试需结合 LangSmith | 否则追踪困难            |
| 多 Agent 并行成本高  | 需要合理设计异步逻辑    |



## LangGraph 的典型应用场景

| 场景                           | 说明                                 |
| ------------------------------ | ------------------------------------ |
| 多步骤推理（Reasoning Chains） | 需要判断、循环、并行的任务           |
| 多 Agent 协作系统              | 规划、执行、审阅、总结               |
| 大模型工作流引擎               | 可视化 LLM 调度（如 Airflow for AI） |
| 动态问答系统                   | 具备上下文状态和记忆的智能体         |
| 对话自动化                     | Chatbot + 状态记忆 + 工具调用        |