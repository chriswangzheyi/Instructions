# 数据查询

## CTE（Common Table Expression，公共表表达式）

	select pow(pow(2,2),3) ;

结果

	┌─pow(pow(2, 2), 3)─┐
	│                64 │
	└───────────────────┘


## With


### 定义变量

	WITH 10 AS num
	SELECT *
	FROM xx
	WHERE id < num ;

### 调用函数

	WITH toYYYYMM(ctime) AS dy
	SELECT
	*,
	dy
	FROM log;


### 定义子查询

	WITH
	(
	SELECT *
	FROM log2
	WHERE id = '4'
	) AS x
	SELECT
	*,
	x
	FROM log2;


## Array join

ARRAY JOIN 子句允许在数据表的内部，与数组或嵌套类型的字段进行JOIN 操作，从而将一行
数组展开为多行。类似于hive 中的explode 炸裂函数的功能。

	CREATE TABLE test_arrayjoin
	(
	`name` String,
	`vs` Array(Int8)
	)
	ENGINE = Memory ;
	
	insert into test_arrayjoin values('hangge',[1,2,3]),('mage',[4,5]),('jinge',[]);

查看：

	select * from test_arrayjoin;

	┌─name───┬─vs──────┐
	│ hangge │ [1,2,3] │
	│ mage   │ [4,5]   │
	│ jinge  │ []      │
	└────────┴─────────┘

在一条SELECT 语句中，只能存在一个ARRAY JOIN（使用子查询除外）

	SELECT
	*,
	s
	FROM test_arrayjoin
	ARRAY JOIN vs AS s;


	┌─name───┬─vs──────┬─s─┐
	│ hangge │ [1,2,3] │ 1 │
	│ hangge │ [1,2,3] │ 2 │
	│ hangge │ [1,2,3] │ 3 │
	│ mage   │ [4,5]   │ 4 │
	│ mage   │ [4,5]   │ 5 │
	└────────┴─────────┴───┘


### Left array join

	SELECT
	*,
	s
	FROM test_arrayjoin
	LEFT ARRAY JOIN vs AS s;


	┌─name───┬─vs──────┬─s─┐
	│ hangge │ [1,2,3] │ 1 │
	│ hangge │ [1,2,3] │ 2 │
	│ hangge │ [1,2,3] │ 3 │
	│ mage   │ [4,5]   │ 4 │
	│ mage   │ [4,5]   │ 5 │
	│ jinge  │ []      │ 0 │
	└────────┴─────────┴───┘


## Join

### 准备数据


	create table yg(
	id Int8 ,
	name String ,
	age UInt8 ,
	bid Int8
	)engine=Log ;

	insert into yg values(1,'AA',23,1) ,
	(2,'BB',24,2) ,
	(3,'VV',27,1) ,
	(4,'CC',13,3) ,
	(5,'KK',53,3) ,
	(6,'MM',33,3) ;

	create table bm(
	bid Int8 ,
	name String
	)engine=Log ;
	
	insert into bm values(1,'x'),(2,'Y'),(3,'Z');

	create table gz(
	id Int8 ,
	jb Int64 ,
	jj Int64
	)engine=Log ;

	insert into gz values (1,1000,2000),(1,1000,2000),(2,2000,1233),(3,2000,3000),(4,4000,1000),(5,5000,2000);


查看

	select * from yg;

	┌─id─┬─name─┬─age─┬─bid─┐
	│  1 │ AA   │  23 │   1 │
	│  2 │ BB   │  24 │   2 │
	│  3 │ VV   │  27 │   1 │
	│  4 │ CC   │  13 │   3 │
	│  5 │ KK   │  53 │   3 │
	│  6 │ MM   │  33 │   3 │
	└────┴──────┴─────┴─────┘

	select * from bm;

	┌─bid─┬─name─┐
	│   1 │ x    │
	│   2 │ Y    │
	│   3 │ Z    │
	└─────┴──────┘

	select * from gz;

	┌─id─┬───jb─┬───jj─┐
	│  1 │ 1000 │ 2000 │
	│  1 │ 1000 │ 2000 │
	│  2 │ 2000 │ 1233 │
	│  3 │ 2000 │ 3000 │
	│  4 │ 4000 │ 1000 │
	│  5 │ 5000 │ 2000 │
	└────┴──────┴──────┘



### all inner join


	select
	*
	from
	yg
	all inner join
	gz
	on
	yg.id = gz.id ;

结果

	┌─id─┬─name─┬─age─┬─bid─┬─gz.id─┬───jb─┬───jj─┐
	│  1 │ AA   │  23 │   1 │     1 │ 1000 │ 2000 │
	│  1 │ AA   │  23 │   1 │     1 │ 1000 │ 2000 │
	│  2 │ BB   │  24 │   2 │     2 │ 2000 │ 1233 │
	│  3 │ VV   │  27 │   1 │     3 │ 2000 │ 3000 │
	│  4 │ CC   │  13 │   3 │     4 │ 4000 │ 1000 │
	│  5 │ KK   │  53 │   3 │     5 │ 5000 │ 2000 │
	└────┴──────┴─────┴─────┴───────┴──────┴──────┘


### any inner join

	select
	*
	from
	yg
	any inner join
	gz
	on yg.id = gz.id ;


结果

	┌─id─┬─name─┬─age─┬─bid─┬─gz.id─┬───jb─┬───jj─┐
	│  1 │ AA   │  23 │   1 │     1 │ 1000 │ 2000 │
	│  2 │ BB   │  24 │   2 │     2 │ 2000 │ 1233 │
	│  3 │ VV   │  27 │   1 │     3 │ 2000 │ 3000 │
	│  4 │ CC   │  13 │   3 │     4 │ 4000 │ 1000 │
	│  5 │ KK   │  53 │   3 │     5 │ 5000 │ 2000 │
	└────┴──────┴─────┴─────┴───────┴──────┴──────┘


### 多表查询

	select
	*
	from
	yg
	left join
	gz
	on yg.id = gz.id
	inner join
	bm
	on
	yg.bid = bm.bid ;


结果

	┌─yg.id─┬─yg.name─┬─yg.age─┬─yg.bid─┬─gz.id─┬─gz.jb─┬─gz.jj─┬─bm.bid─┬─bm.name─┐
	│     1 │ AA      │     23 │      1 │     1 │  1000 │  2000 │      1 │ x       │
	│     1 │ AA      │     23 │      1 │     1 │  1000 │  2000 │      1 │ x       │
	│     2 │ BB      │     24 │      2 │     2 │  2000 │  1233 │      2 │ Y       │
	│     3 │ VV      │     27 │      1 │     3 │  2000 │  3000 │      1 │ x       │
	│     4 │ CC      │     13 │      3 │     4 │  4000 │  1000 │      3 │ Z       │
	│     5 │ KK      │     53 │      3 │     5 │  5000 │  2000 │      3 │ Z       │
	│     6 │ MM      │     33 │      3 │     0 │     0 │     0 │      3 │ Z       │
	└───────┴─────────┴────────┴────────┴───────┴───────┴───────┴────────┴─────────┘


## ASOF

ASOF 是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件asof_column。

	create table emp1(
	id Int8 ,
	name String ,
	ctime DateTime
	)engine=Log ;
	insert into emp1 values(1,'AA','2021-01-03 00:00:00'),
	(1,'AA','2021-01-02 00:00:00'),
	(2,'CC','2021-01-01 00:00:00'),
	(3,'DD','2021-01-01 00:00:00'),
	(4,'EE','2021-01-01 00:00:00');


	create table emp2(
	id Int8 ,
	name String ,
	ctime DateTime
	)engine=Log ;

	insert into emp2 values(1,'aa','2021-01-02 00:00:00'),
	(1,'aa','2021-01-02 00:00:00'),
	(2,'cc','2021-01-01 00:00:00'),
	(3,'dd','2021-01-01 00:00:00');


查看

	select * from emp1;

	┌─id─┬─name─┬───────────────ctime─┐
	│  1 │ AA   │ 2021-01-03 00:00:00 │
	│  1 │ AA   │ 2021-01-02 00:00:00 │
	│  2 │ CC   │ 2021-01-01 00:00:00 │
	│  3 │ DD   │ 2021-01-01 00:00:00 │
	│  4 │ EE   │ 2021-01-01 00:00:00 │
	└────┴──────┴─────────────────────┘

	select * from emp2;
	
	┌─id─┬─name─┬───────────────ctime─┐
	│  1 │ aa   │ 2021-01-02 00:00:00 │
	│  1 │ aa   │ 2021-01-02 00:00:00 │
	│  2 │ cc   │ 2021-01-01 00:00:00 │
	│  3 │ dd   │ 2021-01-01 00:00:00 │
	└────┴──────┴─────────────────────┘


### ASOF inner join

	select
	*
	from
	emp1
	ASOF inner join
	emp2
	on emp1.id = emp2.id
	and
	emp1.ctime > emp2.ctime;

	┌─id─┬─name─┬───────────────ctime─┬─emp2.id─┬─emp2.name─┬──────────emp2.ctime─┐
	│  1 │ AA   │ 2021-01-03 00:00:00 │       1 │ aa        │ 2021-01-02 00:00:00 │
	└────┴──────┴─────────────────────┴─────────┴───────────┴─────────────────────┘






