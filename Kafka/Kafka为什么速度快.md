# Kafka为什么速度快

## 顺序写磁盘

我们的生产环境中，为了节约成本，大部分服务器仍然使用机械磁盘，而非固态硬盘。我们知道，机械磁盘读写数据，首先需要寻道，将磁头调整到对应的磁道上，紧接着，会进行旋转，将磁头旋转到对应的位置上，最后才是读写数据，寻道跟旋转，占用了磁盘读写的大量时间，所以，Apache Kafka在写磁盘的时候，大量地使用了追加写的模式，减少了磁盘寻道与旋转地时间，从而达到更高的磁盘利用率。


## 大量使用内存页

我们知道，即便是顺序写磁盘，磁盘的读写速度任然比内存慢慢的多得多，好在操作系统已经帮我们解决这个问题了，在Linux操作系统中，Linux会将磁盘中的一些数据读取到内存当中，我们称之为内存页。当需要读写硬盘的时候，都优先在内存页中进行处理。读的话大家比较好理解，就是缓存嘛，写的话如果只写在缓存没有落盘不是会形成脏数据么？的确如此，只有当脏页到达一定比例之后，Linux操作系统才会把数据刷到磁盘当中。在机器发生掉电的时候，的确会出现脏数据。但是，我们更应该使用分布式写到多台机器上来从根本上解决这个问题。并且，写在内存页的另外一个好处是减少应用内存的使用，我们都知道Apache Kafka是用Java语言编写的，不得不避免的便是Java的GC问题，随着应用内存的增多，垃圾回收的时间会更多，带来整体性能的下降。


## 零拷贝技术使用

作为一个消息系统，不可避免的便是消息的拷贝，常规的操作，一条消息，需要从创建者的socket到应用，再到操作系统内核，然后才能落盘。同样，一条消息发送给消费者也要从磁盘到内核到应用再到接受者的socket，中间经过了多次不是很有必要的拷贝。在Linux操作系统中，同样为我们提供了零拷贝技术，零拷贝技术并非真的不用拷贝，而是大大地减少了拷贝次数。举个例子，原本从磁盘到接收者Socket中，需要见过内核态，又要经过Apache Kafka应用，那么有没有可能直接越过这两层状态，达到更少的拷贝次数呢？Java 的NIO库，帮我们实现了这一切，借用JavaNIO库封装的API，我们可以直接使用Linux操作系统的零拷贝技术，让系统更快。

**零拷贝则是直接从内核到内核再到网卡，省去了用户空间的复制。**